import 'dart:convert';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:get_ip/get_ip.dart';
import 'package:grpc/grpc.dart';
import 'App.dart';
import 'StateWidget.dart';
import 'config.dart';
import 'generated/api2.pbgrpc.dart';
import 'dart:async';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:open_file/open_file.dart';
//import 'package:device_apps/device_apps.dart';
import 'package:http/http.dart' as http;

double downloadStatus = 0.0;

class API2 {
  static ClientChannel channel;

  static Future<void> biDirectional(dynamic context) async {
    FirebaseUser firebaseUser = StateWidget.of(context).state.user;
    final channel = ClientChannel(
    host,
    port: 9001,
    options: const ChannelOptions(credentials: ChannelCredentials.insecure()),
    );
    final stub = API2Client(channel);
    final numbers = StreamController<String>();

    IdTokenResult token = await firebaseUser.getIdToken(refresh: true);
    final name = token.token;
    Stream<Request> stream = numbers.stream.map((value) => Request()..requestData = value);
    final call = stub.bidirectionalStream(stream);
    final receivedThree = Completer<bool>();
    final sub = call.listen((number) {

      App.of(context).setState(() {
        String out = 'AddOneCancel: Received ${number.responseData}';
        print(out);
        App.of(context).model.print(out);
      });
      if (number.responseData == "quit") {
        receivedThree.complete(true);
      }
    }, onError: (e) => print('Caught: $e'));
    numbers.add(name);
    numbers.add(name);
    numbers.add(name);
    numbers.add(name);
    await receivedThree.future;
    await call.cancel();
    await Future.wait([sub.cancel(), numbers.close()]);
  }

  static Future<void> getCurrentIpAddress() async {
    // NetworkInterface.list(includeLoopback: true, type: InternetAddressType.any)
    //   .then((List<NetworkInterface> interfaces) {
    //     print(interfaces);
    //     interfaces.forEach((interface) {
    //       // _networkInterface += "### name: ${interface.name}\n";
    //       if (interface.name == "wlan") {
    //         host = interface.addresses[0].address;
    //         ip = 'http://'+host+':9000/';
    //       }
    //       // int i = 0;
    //       // interface.addresses.forEach((address) {
    //       //   _networkInterface += "${i++}) ${address.address}\n";
    //       // });
    //     });
    //   });
    // host = await GetIp.ipAddress;
    // ip = 'http://'+host+':9000/';
  }
  static Timer timer;
  static void heartBeat(StreamController<String> pushstreams) {
    pushstreams.add(new Push(created: DateTime.now(), text: "<3 Heartbeat").toJson().toString());
    print("<3");
  }

  static Future<void> pushStream(dynamic context) async {
    timer?.cancel();
    // getCurrentIpAddress();
    FirebaseUser firebaseUser = StateWidget.of(context).state.user;
    final channel = ClientChannel(
    host,
    port: 9000,
    options: const ChannelOptions(credentials: ChannelCredentials.insecure()),
    );
    final stub = API2Client(channel);
    final pushstreams = StreamController<String>();

    IdTokenResult firebaseToken;
    String token;
    if(enableLogin && firebaseUser != null) {
      firebaseToken = await firebaseUser.getIdToken(refresh: true);
      token = firebaseToken.token;
    } else { token = ""; }
    PushRequest convert(value) {
      PushRequest pr = new PushRequest();
      pr.message  = value;
      pr.idToken = token;
      return pr;
    }
    Stream<PushRequest> stream = pushstreams.stream.map((value) => convert(value) );

    final call = stub.pushStream(stream);
    final receivedThree = Completer<bool>();
    final sub = call.listen((number) {
      print('AddOneCancel: Received ${number.message}');
      if (number.message == "quit") {
        receivedThree.complete(true);
      }
    }, onError: (e) => print('Caught: $e'));
    // pushstreams.add(new Push(created: DateTime.now(), text: "Test").toJson().toString());
    // pushstreams.add(new Push(created: DateTime.now(), text: "Test3").toJson().toString());
    // pushstreams.add(new Push(created: DateTime.now(), text: "Test2").toJson().toString());
    // pushstreams.add(new Push(created: DateTime.now(), text: "Test6").toJson().toString());
    // pushstreams.add(new Push(created: DateTime.now(), text: "Test6").toJson().toString());
    // pushstreams.add(new Push(created: DateTime.now(), text: "Test7").toJson().toString());
    // pushstreams.add(new Push(created: DateTime.now(), text: "Test7").toJson().toString());
    // pushstreams.add(new Push(created: DateTime.now(), text: "Test7").toJson().toString());
    // pushstreams.add(new Push(created: DateTime.now(), text: "quit").toJson().toString());


    timer = Timer.periodic(Duration(seconds: 3), (Timer t) => heartBeat(pushstreams));

    await receivedThree.future;
    await call.cancel();
    await Future.wait([sub.cancel(), pushstreams.close()]);
  }
}

final String _table = 'push';
final String _id = 'id';
final String _text = 'text';
final String _created = 'created';

class Push {
  int idPush;
  String text;
  DateTime created;

  Push({this.idPush, this.text, this.created});

  factory Push.fromJson(Map<String, dynamic> json) {
    return Push(
      idPush: json['id'],
      text: json['text']!=null?json['text']:"",
      created: DateTime.parse(json['created']),
    );
  }
  Map<String, dynamic> toJson() => {
  '$_id': this.idPush,
  '$_text': this.text,
  '$_created': this.created.toIso8601String(),
  };
}

class API1 {
  
  static Future<http.Response> request(String method, String endpoint, [ Map<String, dynamic> data = const {}, FirebaseUser user ] ) async {
    http.Response response;
    String target = ip+endpoint;
    String _idtoken = "";
    Map<String, dynamic> mybody = {};

    Map<String, String> headers = {
      'Content-type' : 'application/json', 
      'Accept': 'application/json',
    };

    if(user != null) {
      await user.getIdToken(refresh: true).then((token) {
        _idtoken = token.token;
      });
      mybody = {"idtoken": _idtoken};
    }

    if(data != null)
      if (data.isNotEmpty) {
        mybody.addAll(data);
      }

    String encoded = jsonEncode(mybody);

    switch(method) {
      case "PATCH":
        response = await http.patch(target, body: encoded, headers: headers);
        break;
      case "POST":
        response = await http.post(target, body: encoded, headers: headers);
        break;
      case "PUT":
        break;
      case "GET":
        response = await http.get(target, headers: headers);
        break;
      case "DELETE":
        break;
      case "HEAD":
        break;
      case "READ":
        break;
      case "READBYTES":
        break;
    };
    return response;
  }
}

class APK {

  static Future<Map<String, String>> gatherHead(String url) async {
    var response = await http.head(url);
    if (response.statusCode == 200) {
      return response.headers;
    } else {
      throw Exception('Failed to load HEAD');
    }
  }

  //static Future<Application> gatherInfo() async {
  //  Application app = await DeviceApps.getApp('com.wera.wera_app');
  //  return app;
  //}

  static downloadFile(String url, Function callback, {String filename}) async {
    var httpClient = http.Client();
    var request = new http.Request('GET', Uri.parse(url));
    var response = httpClient.send(request);
    String dir = (await getApplicationDocumentsDirectory()).path;
    
    List<List<int>> chunks = new List();
    int downloaded = 0;
    
    response.asStream().listen((http.StreamedResponse r) {
      
      r.stream.listen((List<int> chunk) {
        // Display percentage of completion
        // debugPrint('downloadPercentage: ${downloaded / r.contentLength * 100}');
        callback(downloaded / r.contentLength);

        chunks.add(chunk);
        downloaded += chunk.length;
      }, onDone: () async {
        // Display percentage of completion
        // debugPrint('done - downloadPercentage: ${downloaded / r.contentLength * 100}');
        callback(downloaded / r.contentLength);

        // Save the file
        File file = new File('$dir/$filename');
        final List<int> bytes = List<int>(r.contentLength);
        int offset = 0;
        for (List<int> chunk in chunks) {
          bytes.setRange(offset, offset + chunk.length, chunk);
          offset += chunk.length;
        }
        await file.writeAsBytes(bytes);
        APK.open(file);
        return;
      });
    });
  }

  static Future<String> get _localPath async {
    final directory = await getApplicationDocumentsDirectory();
    return directory.path;
  }

  static Future<File> get _localFile async {
    final path = await _localPath;
    return File('$path/counter.apk');
  }

  //static open() async {
  //  _localPath.then( (p) { OpenFile.open(p); });
  //}

  static open(File file) async {
    OpenFile.open(file.path);
  }


  static Future<File> writeFile(List<int> content) async {
    final file = await _localFile;
    //Stream<List<int>> stream = Stream.fromFuture(file);
    // Write the file.
    file.delete();
    file.create();
    return file.writeAsBytes(content);
  }

  static Future<List<int>> readFile() async {
    try {
      final file = await _localFile;

      // Read the file.
      List<int> contents = await file.readAsBytes();

      return contents;
    } catch (e) {
      // If encountering an error, return 0.
      return e;
    }
  }


  /*static setUpAll() async {
    // Create a temporary directory.
    final directory = await Directory.systemTemp.createTemp();

    // Mock out the MethodChannel for the path_provider plugin.
    const MethodChannel('plugins.flutter.io/path_provider')
        .setMockMethodCallHandler((MethodCall methodCall) async {
      // If you're getting the apps documents directory, return the path to the
      // temp directory on the test environment instead.
      if (methodCall.method == 'getApplicationDocumentsDirectory') {
        return directory.path;
      }
      return null;
    });
  }*/

  static List<int> file;

  static Future<File> fetchAPK() async {
    final response = await http.get('{WERA_PROJECTS_DOMAIN}:8000/app.apk');
    if (response.statusCode == 200) {
      APK.file = response.bodyBytes;
      return writeFile(response.bodyBytes);
    } else {
      throw Exception('Failed to load album');
    }
  }

  static Future<String> getOnlineVersion() async {
    final response = await http.get('{WERA_PROJECTS_DOMAIN}:8000/version.txt');
    if (response.statusCode == 200) {
      return response.body;
    } else {
      throw Exception('Failed to load album');
    }
  }
}

class Network {
  static Future<bool> isOnline() async {
    try {
      final result = await InternetAddress.lookup('google.com');
      if (result.isNotEmpty && result[0].rawAddress.isNotEmpty) {
        print('connected');
        return true;
      }
    } on SocketException catch (_) {
      print('not connected');
      return false;
    }
  }
}
